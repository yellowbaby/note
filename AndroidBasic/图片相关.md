### 服务器解析得到图片URL显示图片

 1. 使用HttpURLConnection从服务器解析txt文件得到下载路径
 
``` java
    //解析服务器的txt文件存入List<String> mImagePaths
    private void loadImagePaths() {
        try {
            String urlPath = "http://192.168.87.2:8080//img/photo.txt";
            URL url = new URL(urlPath);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            if (connection.getResponseCode() == 200) {
                InputStream is = connection.getInputStream();
                BufferedReader reader = new BufferedReader(new InputStreamReader(is));
                String line = null;
                while ((line = reader.readLine()) != null) {
                    mImagePaths.add(line);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```
　photo.txt文件
 

``` xml
http://192.168.87.2:8080/img/a.png
http://192.168.87.2:8080/img/b.png
http://192.168.87.2:8080/img/c.png
http://192.168.87.2:8080/img/d.png
http://192.168.87.2:8080/img/f.png
```

 2. 根据路径加载图片显示在ImageView mIv

``` java
    //根据路径加载图片显示在ImageView mIv
    private void loadImageByPath(String imagePath) {
        try {
            URL url = new URL(imagePath);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            if (connection.getResponseCode() == 200) {
                InputStream is = connection.getInputStream();
                final Bitmap bmp = BitmapFactory.decodeStream(is);
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mIv.setImageBitmap(bmp);
                    }
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```
3. 添加缓存机制

``` java
    //根据路径加载图片显示在ImageView mIv
    private void loadImageByPath(String imagePath) {

        String localImagePath = imagePath.substring(imagePath.lastIndexOf("/") + 1);//得到文件名
        try {
            File file = new File(getFilesDir(), localImagePath);//确定本地文件地址
            if (file.exists() && file.length() > 0) {//如果本地有缓存，就直接加载图片
                final Bitmap bmp = BitmapFactory.decodeStream(new FileInputStream(file));
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mIv.setImageBitmap(bmp);
                    }
                });
                return;
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        try {//本地没有缓存再从服务器加载
            URL url = new URL(imagePath);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            if (connection.getResponseCode() == 200) {
                InputStream is = connection.getInputStream();
                final Bitmap bmp = BitmapFactory.decodeStream(is);
                FileOutputStream fos = openFileOutput(localImagePath, MODE_PRIVATE);
                bmp.compress(Bitmap.CompressFormat.PNG, 100, fos);
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mIv.setImageBitmap(bmp);
                    }
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```

### 模拟新闻客户端数据展示

 1. 创建NetWork工具类，根据url返回得到数据流
 
``` java
public class NetWorkUtil {

    public static InputStream getStream(String urlPath) throws Exception {
        URL url = new URL(urlPath);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        if (conn.getResponseCode() == 200) {
            return conn.getInputStream();
        }
        return null;
    }

}
```

 2. 创建工具类解析从服务器拿到的xml文件输入流