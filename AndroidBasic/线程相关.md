### AsyncTask
#### AsyncTask概述

 1. AsyncTask是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程更新UI
 2.  AsyncTask只能在主线程被使用，并且只能被使用一次，execute方法必须在UI线程调用

#### AsyncTask用法

 1. 抽象方法解释

```java
//是一个抽象的泛型类，提供了Params, Progress, Result三个泛型参数
//Params代表参数的类型
//Progress代表后台执行进度的类型
//Result是返回结果的类型
public abstract class AsyncTask<Params, Progress, Result> {
	...
    //主线程中执行，做一些准备工作
  	protected void onPreExecute() {}
  
    //在线程池中执行，用于执行异步任务，params传入的参数
   	protected abstract Result doInBackground(Params... params传入的参数);
  
  	//主线程中执行，当后台任务执行进度发生改变时调用
    protected void onProgressUpdate(Progress... values) {}
  
    //主线程中执行，异步任务执行完成后，此方法会被调用
  	protected void onPostExecute(Result result) {}	
  
    ...
}
```
 
 2. 创建DownloadTask继承AsyncTask

```java
class DownloadTask extends AsyncTask<Void, Integer, Boolean> {

	@Override
	protected void onPreExecute() {
		progressDialog.show(); // 显示进度对话框
	}

	@Override
	protected Boolean doInBackground(Void... params) {
		try {
			while (true) {
				int downloadPercent = doDownload(); // 这是一个虚构的方法
				publishProgress(downloadPercent);
				if (downloadPercent >= 100) {
					break;
				}
			}
		} catch (Exception e) {
			return false;
		}
		return true;
	}

	@Override
	protected void onProgressUpdate(Integer... values) {
		// 在这里更新下载进度
		progressDialog.setMessage("Downloaded " + values[0] + "%");
	}

	@Override
	protected void onPostExecute(Boolean result) {
		progressDialog.dismiss(); // 关闭进度对话框
		// 在这里提示下载结果
		if (result) {
			Toast.makeText(context, "Download succeeded", Toast.LENGTH_SHORT)
					.show();
		} else {
			Toast.makeText(context, " Download failed", Toast.LENGTH_SHORT)
					.show();
		}
	}
}
```

 3. 主线程中调用execute方法执行

```java
new DownloadTask().execute();
```

#### AsyncTask原理

 1. 先从execute开始，可以看出onPreExecute方法被首先调用

```java
//是一个抽象的泛型类，提供了Params, Progress, Result三个泛型参数
//Params代表参数的类型
//Progress代表后台执行进度的类型
//Result是返回结果的类型
public abstract class AsyncTask<Params, Progress, Result> {
	...
    public final AsyncTask<Params, Progress, Result> execute(Params... params) {
        return executeOnExecutor(sDefaultExecutor, params);//sDefaultExecutor是一个串行线程池
    }
  
    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,
            Params... params) {
        if (mStatus != Status.PENDING) {
            switch (mStatus) {
                case RUNNING:
                    throw new IllegalStateException("Cannot execute task:"
                            + " the task is already running.");
                case FINISHED:
                    throw new IllegalStateException("Cannot execute task:"
                            + " the task has already been executed "
                            + "(a task can be executed only once)");
            }
        }

        mStatus = Status.RUNNING;

        onPreExecute();//该方法被首先调用

        mWorker.mParams = params;
        exec.execute(mFuture);

        return this;
    }
  
    //设计为空让子类继承实现
    @MainThread
    protected void onPreExecute() {
    }
    ...
}
```

 2. 然后再调用sDefaultExecutor.execute


```java
//是一个抽象的泛型类，提供了Params, Progress, Result三个泛型参数
//Params代表参数的类型
//Progress代表后台执行进度的类型
//Result是返回结果的类型
public abstract class AsyncTask<Params, Progress, Result> {
	...
    public static final Executor SERIAL_EXECUTOR = new SerialExecutor();
    private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;
    private static class SerialExecutor implements Executor {
        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();
        Runnable mActive;

        public synchronized void execute(final Runnable r) {
            mTasks.offer(new Runnable() {//将任务加入等待队列
                public void run() {
                    try {
                        r.run(); 
                    } finally {
                        scheduleNext();//执行完后进行下一个任务
                    }
                }
            });
            if (mActive == null) {//如果没有任务就进行下一个任务
                scheduleNext();
            }
        }

        protected synchronized void scheduleNext() {
            if ((mActive = mTasks.poll()) != null) {
                THREAD_POOL_EXECUTOR.execute(mActive);//THREAD_POOL_EXECUTOR是执行线程
            }
        }
    }
    ...
}
```

从上面可以看出，AsyncTask有两个线程池，SerialExecutor和THREAD_POOL_EXECUTOR

SerialExecutor线程池用来排队，THREAD_POOL_EXECUTOR用来真正执行任务

由于FutureTask的run方法最终会调用mWorker的call方法在线程池中执行
```java
public abstract class AsyncTask<Params, Progress, Result> {
	...
    public AsyncTask() {
        mWorker = new WorkerRunnable<Params, Result>() {
            public Result call() throws Exception {
                mTaskInvoked.set(true);

                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                //noinspection unchecked
                Result result = doInBackground(mParams);//后台线程在线程池中被执行
                Binder.flushPendingCommands();
                return postResult(result);
            }
        };

        mFuture = new FutureTask<Result>(mWorker) {
            @Override
            protected void done() {
                try {
                    postResultIfNotInvoked(get());
                } catch (InterruptedException e) {
                    android.util.Log.w(LOG_TAG, e);
                } catch (ExecutionException e) {
                    throw new RuntimeException("An error occurred while executing doInBackground()",
                            e.getCause());
                } catch (CancellationException e) {
                    postResultIfNotInvoked(null);
                }
            }
        };
    }
    ...
}
```

最终调用了postResult(result) 把结果返回，发送了一个MESSAGE_POST_RESULT的message到handler

```java
public abstract class AsyncTask<Params, Progress, Result> {
	...
    private Result postResult(Result result) {
        @SuppressWarnings("unchecked")
        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,
                new AsyncTaskResult<Result>(this, result));
        message.sendToTarget();
        return result;
    }
  
    //这个handler用来切到主线程，所以必须在主线程才可以使用AsyncTask
    private static class InternalHandler extends Handler {
        public InternalHandler() {
            super(Looper.getMainLooper());
        }

        @SuppressWarnings({"unchecked", "RawUseOfParameterizedType"})
        @Override
        public void handleMessage(Message msg) {
            AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;
            switch (msg.what) {
                case MESSAGE_POST_RESULT://执行成功后
                    // There is only one result
                    result.mTask.finish(result.mData[0]);
                    break;
                case MESSAGE_POST_PROGRESS://更新进度，调用publishProgress的时候
                    result.mTask.onProgressUpdate(result.mData);
                    break;
            }
        }
    }
    ...
}
```

最后会调用finish方法

```java
public abstract class AsyncTask<Params, Progress, Result> {
	...
    private void finish(Result result) {
        if (isCancelled()) {
            onCancelled(result);
        } else {
            onPostExecute(result);//执行完成后调用
        }
        mStatus = Status.FINISHED;
	}
	...
}
```

总结流程：

 1. 调用execute后首先执行onPreExecute方法，此时还在UI线程
 2. 内部的线程池开启后台线程调用了doInBackground方法
 3. 使用handler将结果切回主线程根据状态码执行onProgressUpdate或者onPostExecute


### Handle+Message
